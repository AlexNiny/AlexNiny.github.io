{"meta":{"title":"AlexNine","subtitle":null,"description":null,"author":"AlexNine","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"排序算法在JDK中的应用","slug":"排序算法在JDK中的应用","date":"2019-05-27T13:37:29.000Z","updated":"2019-05-27T13:44:32.769Z","comments":true,"path":"2019/05/27/排序算法在JDK中的应用/","link":"","permalink":"http://yoursite.com/2019/05/27/排序算法在JDK中的应用/","excerpt":"","text":"JDK8中的排序算法JDK中对于数组的排序使用比较的多的是Arrays.sort()和Arrays.parallelSort()，前者是传统的排序算法，后者是JDK8新增的并行排序算法，基于fork/join框架,今天主要是分析Arrays.sort()的底层实现。Arrays.sort()可以对所有的基本类型（除boolean）和Object进行排序，如果是数值类型的数就直接按照从大到小的顺序排列，如果是String类型的数组就按照其ASCII码进行排序，如果是对象就按照对象内部实现的compareTo()方法进行比较排序，并且使用的是归并排序。这里我们通过分析Arrays.sort(int[] a)来分析一下JDK的实现流程和方式。 外层方法第一步，调用Arrays.sort(int[] a)后，直接调用了DualPivotQuicksort.sort()字面意思是双轴快速排序，如下面代码所示。12345678910111213141516/** * Sorts the specified array into ascending numerical order. * 将数组按照升序排列 * &lt;p&gt;Implementation note: The sorting algorithm is a Dual-Pivot Quicksort * by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm * offers O(n log(n)) performance on many data sets that cause other * quicksorts to degrade to quadratic performance, and is typically * faster than traditional (one-pivot) Quicksort implementations. * 简单的翻译：算法的三个大佬作者。这个双轴快速排序可以为那些让传统快速排序性能下降的数据集提供O(n log(n))的时间复杂度，所以速度比传统的快速排序快 * 这里是为什么双轴快排比普通快排更快的Paper：https://arxiv.org/pdf/1511.01138.pdf * 另外一个博主的笔记：https://www.jianshu.com/p/2c6f79e8ce6e * @param a the array to be sorted */ public static void sort(int[] a) &#123; DualPivotQuicksort.sort(a, 0, a.length - 1, null, 0, 0); &#125; 改进后的归并排序现在我们继续跟踪代码进入sort()的内部实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132/** * Sorts the specified range of the array using the given * workspace array slice if possible for merging * 在条件允许的情况下，使用给定的辅助空间对指定的数组范围内进行排序。 * @param a the array to be sorted 要被排序的数组 * @param left the index of the first element, inclusive, to be sorted 第一个元素的位置 * @param right the index of the last element, inclusive, to be sorted 最后一个元素的位置 * @param work a workspace array (slice) 工作辅助数组 * @param workBase origin of usable space in work array 工作辅助数组的扩容参数 * @param workLen usable size of work array 工作辅助数组的长度 * 此代码我进行了一些缩进和对齐 */ static void sort(int[] a, int left, int right,int[] work, int workBase, int workLen) &#123; // Use Quicksort on small arrays //If the length of an array to be sorted is less than this constant, Quicksort is used in preference to merge sort. //当待排序的数组长度小于286时使用快速排序，这时快排的表现好于归并排序 // private static final int QUICKSORT_THRESHOLD = 286; if (right - left &lt; QUICKSORT_THRESHOLD)&#123; sort(a, left, right, true); return; &#125; /* * Index run[i] is the start of i-th run * (ascending or descending sequence). * 设置run数组第一个位置即需要排序的序列的第一个元素，长度就是是否有序的临界值 * //The maximum number of runs in merge sort. * private static final int MAX_RUN_COUNT = 67; */ int[] run = new int[MAX_RUN_COUNT + 1]; int count = 0; run[0] = left; // Check if the array is nearly sorted //检查数组是否接近有序（无序程度） //这里的检查思路是：任一的数组都可以分割成若干个递增或递减的数组，比如&#123;12,33,2,10,23,21,15&#125;可以分成&#123;12,33&#125;,&#123;2,10,23&#125;,&#123;21,15&#125;这三个子数组要么是递增的要么是递减的 //上面的run数组就是用于存取子数组开始的下标的，然后通过比较run数组中元素个数来确定数组是否基本有序。如果大于MAX_RUN_COUNT那么就认定数组基本无序 for (int k = left; k &lt; right; run[count] = k) &#123; // ascending 处理递增数组的位置 if (a[k] &lt; a[k + 1]) &#123; while (++k &lt;= right &amp;&amp; a[k - 1] &lt;= a[k]); // descending 处理递减数组的位置 &#125; else if (a[k] &gt; a[k + 1]) &#123; while (++k &lt;= right &amp;&amp; a[k - 1] &gt;= a[k]); //同时将其转换为递增 for (int lo = run[count] - 1, hi = k; ++lo &lt; --hi; ) &#123; int t = a[lo]; a[lo] = a[hi]; a[hi] = t; &#125; // equal 处理相等元素 &#125; else &#123; //The maximum length of run in merge sort. 归并排序的最多运行次数 //private static final int MAX_RUN_LENGTH = 33; //这一步的意思是如果相等的序列等于MAX_RUN_LENGTH就直接执行快速排序。*不是很不清楚为什么要这么做* for (int m = MAX_RUN_LENGTH; ++k &lt;= right &amp;&amp; a[k - 1] == a[k]; ) &#123; if (--m == 0) &#123; sort(a, left, right, true); return; &#125; &#125; &#125; /* * The array is not highly structured, * use Quicksort instead of merge sort. * 每次循环完成检查count值是否已经等于无序临界值，如果直接等于临界值，那么就直接使用快速排序 * 待排序列越接近有序，归并排序效率越高 */ if (++count == MAX_RUN_COUNT) &#123; sort(a, left, right, true); return; &#125; &#125; // Check special cases 检查特殊的情况 // Implementation note: variable &quot;right&quot; is increased by 1.在right变量的基础上加1 if (run[count] == right++) &#123; // The last run contains one element run数组的最后添加一个哨兵元素，值为right+1 run[++count] = right; &#125; else if (count == 1) &#123; // The array is already sorted 如果只有一个单调序列那么说明数组本身就是有序的 直接跳出 return; &#125; //这下面就是归并排序的相关操作了，到这一步时说明数组通过了初步筛选，即数组长度大于286且接近有序 // Determine alternation base for merge 确定归并排序的交替标准 byte odd = 0; for (int n = 1; (n &lt;&lt;= 1) &lt; count; odd ^= 1); // Use or create temporary array b for merging 为归并使用或者创建一个临时数组 int[] b; // temp array; alternates with a 临时数组，为a归并时提供临时存储，即辅助空间 int ao, bo; // array offsets from &apos;left&apos;设置偏移指针 int blen = right - left; // space needed for b 数组b需要的长度 //操作work数组的相关属性 if (work == null || workLen &lt; blen || workBase + blen &gt; work.length) &#123; work = new int[blen]; workBase = 0; &#125; //通过odd确定a b数组的内容 //通过此操作后 a和b中必然有一个为原数组有一个为作为辅助空间的数组 if (odd == 0) &#123; System.arraycopy(a, left, work, workBase, blen); b = a; bo = 0; a = work; ao = workBase - left; &#125; else &#123; b = work; ao = 0; bo = workBase - left; &#125; // Merging 归并操作 for (int last; count &gt; 1; count = last) &#123; //归并次数边界 //具体的归并过程 for (int k = (last = 0) + 2; k &lt;= count; k += 2) &#123; int hi = run[k], mi = run[k - 1]; for (int i = run[k - 2], p = i, q = mi; i &lt; hi; ++i) &#123; if (q &gt;= hi || p &lt; mi &amp;&amp; a[p + ao] &lt;= a[q + ao]) &#123; b[i + bo] = a[p++ + ao]; &#125; else &#123; b[i + bo] = a[q++ + ao]; &#125; &#125; run[++last] = hi; &#125; //如果其中的一个子序列元素个数为奇数，就直接把这个序列复制到b中 if ((count &amp; 1) != 0) &#123; for (int i = right, lo = run[count - 1]; --i &gt;= lo; b[i + bo] = a[i + ao] ); run[++last] = right; &#125; //交换数组，更新指针，准备进行下一次归并 int[] t = a; a = b; b = t; int o = ao; ao = bo; bo = o; &#125; &#125; 以上便是JDK对于sort排序中归并排序部分的优化处理，总结而言就是当待排序的数组长度大于等于286时开始考虑使用归并排序。在此同时还需要考虑的条件是待排序的数组是否是基本有序的，JDK采用的办法是将待排序数组分成若干个单调递增或者递减的数组，如果分成的小数组的个数大于67就认为这个数组基本上是无序的此时就直接调用了快速排序，还有个我不是很理解的条件就是当带待排序的数组中相等的元素子序列长度大于等于MAX_RUN_LENGTH（33）时就直接使用快速排序。 改进后的快速排序在分析上述代码时，可以发现程序会在特殊的情况调用sort()方法即改进后得快速排序，接下来就来分析sort()快速排序的代码实现。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352/** * Sorts the specified range of the array by Dual-Pivot Quicksort. * 通过双轴快速排序对指定范围内的数据进行排序 * @param a the array to be sorted 被排序的数组 * @param left the index of the first element, inclusive, to be sorted 需要排序的第一个元素的位置（包括在内） * @param right the index of the last element, inclusive, to be sorted 需要排序的最后一个元素的位置（包括在内） * @param leftmost indicates if this part is the leftmost in the range leftmost表示该部分是否是范围内最左的部分 */ private static void sort(int[] a, int left, int right, boolean leftmost) &#123; int length = right - left + 1; // Use insertion sort on tiny arrays //当数组的长度很小时就是用插入排序，INSERTION_SORT_THRESHOLD=47 if (length &lt; INSERTION_SORT_THRESHOLD) &#123; if (leftmost) &#123; /* * Traditional (without sentinel) insertion sort, 传统的插入排序，不使用哨兵元素 * optimized for server VM, is used in case of 针对最左边的部分的情况进行了服务器虚拟机的优化 * the leftmost part. */ for (int i = left, j = i; i &lt; right; j = ++i) &#123; int ai = a[i + 1]; while (ai &lt; a[j]) &#123; a[j + 1] = a[j]; if (j-- == left) &#123; break; &#125; &#125; a[j + 1] = ai; &#125; &#125; else &#123; /* * Skip the longest ascending sequence. 跳过最长的升序情况，提高算法效率 */ do &#123; if (left &gt;= right) &#123; return; &#125; &#125; while (a[++left] &gt;= a[left - 1]); /* * Every element from adjoining part plays the role 在这种排序方法中相邻的每个元素都起到了哨兵的作用 * of sentinel, therefore this allows us to avoid the 这种办法可以避免我们每次迭代时都要进行左范围检查。 * left range check on each iteration. Moreover, we use 而且我们还使用了一个效率更好的算法，我们称之为“双插入排序”， * the more optimized algorithm, so called pair insertion 在快速排序的上下文中（即满足进入sort()方法的数组）他比传统的 * sort, which is faster (in the context of Quicksort) 插入排序更快 * than traditional implementation of insertion sort. */ for (int k = left; ++left &lt;= right; k = ++left) &#123; int a1 = a[k], a2 = a[left]; if (a1 &lt; a2) &#123; a2 = a1; a1 = a[left]; &#125; while (a1 &lt; a[--k]) &#123; a[k + 2] = a[k]; &#125; a[++k + 1] = a1; while (a2 &lt; a[--k]) &#123; a[k + 1] = a[k]; &#125; a[k + 1] = a2; &#125; int last = a[right]; while (last &lt; a[--right]) &#123; a[right + 1] = a[right]; &#125; a[right + 1] = last; &#125; return; &#125; //从这里开始是对待排序的元素进行分组处理 // Inexpensive approximation of length / 7 // 使用length/7作为近似的加权长度 int seventh = (length &gt;&gt; 3) + (length &gt;&gt; 6) + 1; /* * Sort five evenly spaced elements around (and including) the 在范围内的中心元素附近找到5个均匀间隔的元素 * center element in the range. These elements will be used for 这些元素将用于下面代码中的枢轴选择 * pivot selection as described below. The choice for spacing 根据经验，这些元素的间距能够很好的应对和处理各种各样的输入（待排序的数组） * these elements was empirically determined to work well on * a wide variety of inputs. */ int e3 = (left + right) &gt;&gt;&gt; 1; // The midpoint int e2 = e3 - seventh; int e1 = e2 - seventh; int e4 = e3 + seventh; int e5 = e4 + seventh; // Sort these elements using insertion sort 使用插入排序对这些元素进行排序 if (a[e2] &lt; a[e1]) &#123; int t = a[e2]; a[e2] = a[e1]; a[e1] = t; &#125; if (a[e3] &lt; a[e2]) &#123; int t = a[e3]; a[e3] = a[e2]; a[e2] = t; if (t &lt; a[e1]) &#123; a[e2] = a[e1]; a[e1] = t; &#125; &#125; if (a[e4] &lt; a[e3]) &#123; int t = a[e4]; a[e4] = a[e3]; a[e3] = t; if (t &lt; a[e2]) &#123; a[e3] = a[e2]; a[e2] = t; if (t &lt; a[e1]) &#123; a[e2] = a[e1]; a[e1] = t; &#125; &#125; &#125; if (a[e5] &lt; a[e4]) &#123; int t = a[e5]; a[e5] = a[e4]; a[e4] = t; if (t &lt; a[e3]) &#123; a[e4] = a[e3]; a[e3] = t; if (t &lt; a[e2]) &#123; a[e3] = a[e2]; a[e2] = t; if (t &lt; a[e1]) &#123; a[e2] = a[e1]; a[e1] = t; &#125; &#125; &#125; &#125;//分组完成 // Pointers 指针 int less = left; // The index of the first element of center part 中心部分第一个元素的位置 int great = right; // The index before the first element of right part 右边第一个元素之前的位置 //五个分位点的值各不相同 if (a[e1] != a[e2] &amp;&amp; a[e2] != a[e3] &amp;&amp; a[e3] != a[e4] &amp;&amp; a[e4] != a[e5]) &#123; /* * Use the second and fourth of the five sorted elements as pivots. 使用五个分位点中的第二个和第四个作为枢轴 * These values are inexpensive approximations of the first and 因为有上面的排序 所以在这里pivot1 &lt;= pivot2 * second terciles of the array. Note that pivot1 &lt;= pivot2. */ int pivot1 = a[e2]; int pivot2 = a[e4]; /* * The first and the last elements to be sorted are moved to the 将要排序的第一个和最后一个元素换到枢轴的位置 * locations formerly occupied by the pivots. When partitioning 当分区操作完成后，枢轴元素将和这个元素交换回到原来的位置 * is complete, the pivots are swapped back into their final 并排除到后续排序之外 * positions, and excluded from subsequent sorting. */ a[e2] = a[left]; a[e4] = a[right]; /* * Skip elements, which are less or greater than pivot values. * 筛选那些比枢轴元素更大或者更小的元素 以此来确定less和great的位置 */ while (a[++less] &lt; pivot1); while (a[--great] &gt; pivot2); /* * Partitioning: * * left part center part right part * +--------------------------------------------------------------+ * | &lt; pivot1 | pivot1 &lt;= &amp;&amp; &lt;= pivot2 | ? | &gt; pivot2 | * +--------------------------------------------------------------+ * ^ ^ ^ * | | | * less k great * * Invariants: * * all in (left, less) &lt; pivot1 * pivot1 &lt;= all in [less, k) &lt;= pivot2 * all in (great, right) &gt; pivot2 * * Pointer k is the first index of ?-part. * 以下的forless-1开始向右遍历至great，把小于pivot1的元素移动到less左边，大于pivot2的元素移动到great右边。 */ //outer标签 outer: for (int k = less - 1; ++k &lt;= great; ) &#123; int ak = a[k]; if (ak &lt; pivot1) &#123; // Move a[k] to left part a[k] = a[less]; /* * Here and below we use &quot;a[i] = b; i++;&quot; instead * of &quot;a[i++] = b;&quot; due to performance issue. * 在这里分开写的原因是因为前者效率更佳 * 想要了解的可以看这里的讨论：https://www.oschina.net/question/3037675_2206753 */ a[less] = ak; ++less; &#125; else if (ak &gt; pivot2) &#123; // Move a[k] to right part while (a[great] &gt; pivot2) &#123; if (great-- == k) &#123; break outer; &#125; &#125; //通过上面已知great&lt;pivot2，但是并不知道great和pivot1的大小关系， //如果它比pivot1还小，需要移动到到less左边，否则只需要交换到k处。 if (a[great] &lt; pivot1) &#123; // a[great] &lt;= pivot2 a[k] = a[less]; a[less] = a[great]; ++less; &#125; else &#123; // pivot1 &lt;= a[great] &lt;= pivot2 a[k] = a[great]; &#125; /* * Here and below we use &quot;a[i] = b; i--;&quot; instead * of &quot;a[i--] = b;&quot; due to performance issue. */ a[great] = ak; --great; &#125; &#125; // Swap pivots into their final positions // 将less-1的元素放到对头，great+1的元素放在队尾 //然后将pivot1放在less-1,pivot2放在great+1 a[left] = a[less - 1]; a[less - 1] = pivot1; a[right] = a[great + 1]; a[great + 1] = pivot2; // Sort left and right parts recursively, excluding known pivots //递归左右部分进行排序 包括已知的轴心 sort(a, left, less - 2, leftmost); sort(a, great + 2, right, false); /* * If center part is too large (comprises &gt; 4/7 of the array), * swap internal pivot values to ends. * 如果中心部分太大(大小超过了整个数组的4/7),就将内部的枢轴值交换到端点 */ if (less &lt; e1 &amp;&amp; e5 &lt; great) &#123; /* * Skip elements, which are equal to pivot values. * 调整less和great指针的位置，即跳过相等的元素 */ while (a[less] == pivot1) &#123; ++less; &#125; while (a[great] == pivot2) &#123; --great; &#125; /* * Partitioning: * * left part center part right part * +----------------------------------------------------------+ * | == pivot1 | pivot1 &lt; &amp;&amp; &lt; pivot2 | ? | == pivot2 | * +----------------------------------------------------------+ * ^ ^ ^ * | | | * less k great * * Invariants: * * all in (*, less) == pivot1 * pivot1 &lt; all in [less, k) &lt; pivot2 * all in (great, *) == pivot2 *这下面的排序和上面的区别在于边界条件的判断 * Pointer k is the first index of ?-part. */ outer: for (int k = less - 1; ++k &lt;= great; ) &#123; int ak = a[k]; if (ak == pivot1) &#123; // Move a[k] to left part a[k] = a[less]; a[less] = ak; ++less; &#125; else if (ak == pivot2) &#123; // Move a[k] to right part while (a[great] == pivot2) &#123; if (great-- == k) &#123; break outer; &#125; &#125; if (a[great] == pivot1) &#123; // a[great] &lt; pivot2 a[k] = a[less]; /* * 浮点零的相关问题：https://stackoverflow.com/questions/13544342/why-do-floating-point-numbers-have-signed-zeros * Even though a[great] equals to pivot1, the 如果a[great]和pivot1是不同符号的浮点零， * assignment a[less] = pivot1 may be incorrect, 即使a[great]这个元素等于pivot1，“a[less] = pivot1”这个赋值操作也可能是不正确的 * if a[great] and pivot1 are floating-point zeros （这里是对单双精度元素排序的一个特例处理，使-0排在+0之前） * of different signs. Therefore in float and 因此在单双精度的排序算法中我们必须使用更加精确的赋值即a[less]=a[great] * double sorting methods we have to use more * accurate assignment a[less] = a[great]. */ a[less] = pivot1; ++less; &#125; else &#123; // pivot1 &lt; a[great] &lt; pivot2 a[k] = a[great]; &#125; a[great] = ak; --great; &#125; &#125; &#125; // Sort center part recursively // 对中心部分进行递归排序 sort(a, less, great, false); &#125; else &#123; // Partitioning with one pivot 采用单轴分区 区别于上面那种情况 /* * Use the third of the five sorted elements as pivot. 使用5个排序好的元素中的第三个作为枢轴元素 * This value is inexpensive approximation of the median. 这个值是数组的中值近似值 */ int pivot = a[e3]; /* * Partitioning degenerates to the traditional 3-way 分区方式退化为传统的3路形式 * (or &quot;Dutch National Flag&quot;) schema:（或者“荷兰国旗”模式） * 荷兰国旗问题（Dutch National Flag Problem）:https://www.cnblogs.com/freelancy/p/7940803.html * left part center part right part * +-------------------------------------------------+ * | &lt; pivot | == pivot | ? | &gt; pivot | * +-------------------------------------------------+ * ^ ^ ^ * | | | * less k great * * Invariants: * * all in (left, less) &lt; pivot * all in [less, k) == pivot * all in (great, right) &gt; pivot * 以下算法与上面算法思路差不多 不再累述 * Pointer k is the first index of ?-part. */ for (int k = less; k &lt;= great; ++k) &#123; if (a[k] == pivot) &#123; continue; &#125; int ak = a[k]; if (ak &lt; pivot) &#123; // Move a[k] to left part a[k] = a[less]; a[less] = ak; ++less; &#125; else &#123; // a[k] &gt; pivot - Move a[k] to right part while (a[great] &gt; pivot) &#123; --great; &#125; if (a[great] &lt; pivot) &#123; // a[great] &lt;= pivot a[k] = a[less]; a[less] = a[great]; ++less; &#125; else &#123; // a[great] == pivot /* * Even though a[great] equals to pivot, the * assignment a[k] = pivot may be incorrect, * if a[great] and pivot are floating-point * zeros of different signs. Therefore in float * and double sorting methods we have to use * more accurate assignment a[k] = a[great]. */ a[k] = pivot; &#125; a[great] = ak; --great; &#125; &#125; /* * Sort left and right parts recursively.对左右部分进行递归排序 * All elements from center part are equal 中间的元素都相等，所以已经排序 * and, therefore, already sorted. */ sort(a, left, less - 1, leftmost); sort(a, great + 1, right, false); &#125; &#125; 上述代码便是jdk1.8中快速排序sort()的源码部分，总结一下主要有以下几个要点 当待排数组的长度小于47时就会直接使用插入排序 选择五个均匀间隔的元素作为使用不同快速排序方法的判断标准 如果五个元素互不相等那么使用双轴快速排序（两个枢轴为e2和e4） 否则使用只有一个枢轴值（e3）进行排序，但是这里还是把待排序数组分成了三个部分分别是大于，等于和小于枢轴的区域 总结 写了好久终于把这篇博客写好了，过程中查了好多的资料看了好多的博客，不过最后还是把这个坑填上了，收获颇多。 写JDK源码的大佬是真的好厉害，注释很清晰，可惜有些注释不能翻译得很准确，还是要提高英语水平。 阅读源码的能力还是要多提升，这次看注释+博客和边调试边理解的方式还是挺不错的。 多学习 多阅读 多思考 PS排序算法写得差不了，接下来准备把数据结构的内容用Java语言全部写一遍。争取在9月份之前完成这个目标。 参考 双轴快排原理解析 JDK源码解析(1)","categories":[{"name":"technology","slug":"technology","permalink":"http://yoursite.com/categories/technology/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}],"keywords":[{"name":"technology","slug":"technology","permalink":"http://yoursite.com/categories/technology/"}]},{"title":"Java实现常见排序算法（二）","slug":"Java实现常见算法-二","date":"2019-05-07T12:49:38.000Z","updated":"2019-05-13T15:11:25.524Z","comments":true,"path":"2019/05/07/Java实现常见算法-二/","link":"","permalink":"http://yoursite.com/2019/05/07/Java实现常见算法-二/","excerpt":"","text":"上次的博客讨论了排序算法中的插入排序和交换排序两个大类，今天将剩下的常见排序算法全部梳理出来 选择排序简单选择排序基本思想:每一趟排序从待排序的序列中选择出最小的元素，顺序放入到元素序列中，直到排序完成。该算法是一个不稳定的算法并且效率与初始数据顺序无关。空间复杂度为O(1)时间复杂度最高，平均，最低都为O(n2)Java实现：12345678910111213141516171819public static int[] selectInsert(int[] n) &#123; int minPos, temp; for (int i = 0; i &lt; n.length; i++) &#123; minPos = i; //遍历找出最小数的位置 for (int j = i + 1; j &lt; n.length; j++) &#123; if (n[j] &lt; n[minPos]) &#123; minPos = j; &#125; &#125; //如果最小数位置不等于当前位置指针，就交换位置，即把数按照从小到大的顺序依次排列 if (minPos != i) &#123; temp = n[i]; n[i] = n[minPos]; n[minPos] = temp; &#125; &#125; return n;&#125; 堆排序基本原理：堆排序是一种树形选择排序算法，其原理是将R[1…n]看成一棵完全二叉树的顺序存储结构。利用完全二叉树中双亲节点和孩子结点的关系，在当前无序区中选择关键字最大（最小）的元素构建成大根堆（小根堆）。堆排序的主要流程便是，建立大（小）根堆，然后输出元素（顶部和底部元素进行交换），再调整堆，直到元素全部输出。堆排序是一个不稳定的算法。堆的定义为：n个关键字序列R[1…n]称为堆，堆通常可以被看做一棵树的数组对象。当且仅当序列满足R[i]$\\leq$R[2i]且R[i]$\\leq$R[2i+1]时称为该堆为大根堆,其中1$\\leq$i$\\leq\\lfloor$n/2$\\rfloor$ 当且仅当序列满足R[i]$\\geq$R[2i]且R[i]$\\geq$R[2i+1]时称为该堆为小根堆,其中1$\\leq$i$\\leq\\lfloor$n/2$\\rfloor$比如在大根堆中，最大的元素放在根节点中，且对于任一非根节点，它的值小于等于其双亲节点的值。对于堆排序来说关键在于构造堆，而建堆是一个反复调整筛选的过程。首先从树的最后一个非叶子节点开始调整，按照堆的性质移动元素位置。如下图便是一个大顶推的调整过程。初始堆建立完成后，就是进行排序操作，排序操作的主要步骤是：以大根堆为例，每一次排序将堆顶元素与堆尾元素进行交换，然后再调用调整堆的算法使除了堆尾元素以外剩下的堆再次调整成一个大根堆，这样循环length-1次就可以将元素调整为从小到大的顺序，完成排序。空间复杂度为O(1)时间复杂度的最高，平均，最低都为O(nlog2n)Java实现：12345678910111213141516171819202122232425262728293031323334353637383940414243//堆排序private static int[] heapSort(int[] n) &#123; //建立堆，从最后一个非叶子节点开始 for (int i = (n.length - 2) / 2; i &gt;= 0; i--) &#123; adjustHeap(n, i, n.length); &#125; int temp; //完成排序，从最后一个元素进行输出，每次循环确定一个元素的位置 for (int i = n.length - 1; i &gt;= 1; i--) &#123; temp = n[0]; n[0] = n[i]; n[i] = temp; // 筛选 R[0] 结点，得到i个结点的堆 adjustHeap(n, 0, i); &#125; return n;&#125;//调整堆public static void adjustHeap(int[] n, int k, int length) &#123; //设置堆顶的值 int temp = n[k]; //从左孩子开始判断 for (int i = k * 2 + 1; i &lt;= length - 1; i = 2 * i + 1) &#123; //如果左孩子小于右孩子 if (i + 1 &lt; length &amp;&amp; n[i] &lt; n[i + 1]) &#123; //取右孩子 i++; &#125; //如果堆顶的值大于左右孩子中的较大者，无需调整 if (temp &gt;= n[i]) &#123; break; &#125; else &#123; //否则的话，将左右孩子中的较大者换到双亲节点 n[k] = n[i]; //然后将k值更新，方便继续向下调整 k = i; &#125; &#125; //将原堆顶位置当入最后调整出来的地方 n[k] = temp;&#125; 归并排序和基数排序归并排序基本思想：“归并”的意思是指将两个或者两个以上的有序表合并成一个新的有序表。假设一个待排序的序列长度为n，首先我们可以将其视为n个有序表，即每个表中元素个数为1，然后我们将n个有序表进行两两归并，得到$\\lceil$n/2$\\rceil$个长度为2或者1的有序表然后再再次基础上进行两两归并直到得到一个长度为n的有序表为止。这种方法就称为2路归并排序。归并排序是一个稳定的排序算法。PS.归并排序的发明者是约翰·冯·诺伊曼，其速度仅次于快速排序(平均状况下)例如我们有一个初始值为[22,11,32,2,12,83,10]的序列，才有2路归并排序第一趟归并后：[11,22],[2,32],[12,83],[10]第二趟归并后：[2,11,22,32],[10,12,83]第三趟归并后：[2,10,11,12,22,32,83]空间复杂度为O(n)时间复杂度的最高，平均，最低都为O(nlog2n)Java实现：1234567891011121314151617181920212223242526272829303132333435//归并排序public static int[] mergeSort(int[] n, int low, int high) &#123; int mid = (low + high) / 2; if (low &lt; high) &#123; mergeSort(n, low, mid); mergeSort(n, mid + 1, high); merge(n, low, mid, high); &#125; return n;&#125;//调整public static void merge(int[] n, int low, int mid, int high) &#123; int[] tempArr; int i = low, j = mid + 1, k = 0; tempArr = Arrays.copyOf(n, high - low + 1); // 把较小的数先移到新数组中 while (i &lt;= mid &amp;&amp; j &lt;= high) &#123; if (n[i] &lt; n[j]) &#123; tempArr[k++] = n[i++]; &#125; else &#123; tempArr[k++] = n[j++]; &#125; &#125; // 把左边剩余的数移入数组 while (i &lt;= mid) &#123; tempArr[k++] = n[i++]; &#125; // 把右边边剩余的数移入数组 while (j &lt;= high) &#123; tempArr[k++] = n[j++]; &#125; // 把新数组中的数覆盖nums数组 System.arraycopy(tempArr, 0, n, low, tempArr.length);&#125; 基数排序(桶子排序)基本思想：基数排序是一种不基于比较的排序，而采用多关键字排序思想，即基于关键字各位的大小进行排序，主要使用“分配”和“收集”两种基本操作对单逻辑关键字进行排序。基数排序又分为最高位优先(MSD)排序和最低位优先(LSD)排序。他的主要思想是将待排序的整数按位数切割成不同的数字，然后对每一位的数进行单独的比较，具体做法是：将所有待比较数值统一为同样的数位长度，如有不同位数则在前面进行补零操作，然后从最低位开始，依次进行一次排序，这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。举个栗子：待排序的数据为[222,123,580,996,965,854,775]，使用最低位优先排序第一趟将最低位进行排序：[580,222,123,854,965,775,996]第二趟将中间位进行排序：[222,123,854,965,775,580,996]第三趟将最高位进行排序：[123,222,580,775,854,965,996]空间复杂度：一趟排序需要的辅助空间为O(r)(r个队列或桶)用于存放d待排序的数时间复杂度：O(d(n+r)),d趟的分配和收集，一趟分配为O(n)，一趟收集为O(r)。Java实现(代码参考百度百科)12345678910111213141516171819202122232425262728//d表示最大的数有多少位public static int[] radixSort(int[] number, int d) &#123; //控制键值排序依据在哪一位 int k = 0,n = 1,m = 1; //数组的第一维表示可能的余数0-9 int[][] temp = new int[10][number.length]; //数组orderp[i]用来表示该位是i的数的个数 int[] order = new int[10]; while (m &lt;= d) &#123; for (int value : number) &#123; int lsd = ((value / n) % 10); temp[lsd][order[lsd]] = value; order[lsd]++; &#125; for (int i = 0; i &lt; 10; i++) &#123; if (order[i] != 0) for (int j = 0; j &lt; order[i]; j++) &#123; number[k] = temp[i][j]; k++; &#125; order[i] = 0; &#125; n *= 10; k = 0; m++; &#125; return number;&#125;","categories":[{"name":"technology","slug":"technology","permalink":"http://yoursite.com/categories/technology/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}],"keywords":[{"name":"technology","slug":"technology","permalink":"http://yoursite.com/categories/technology/"}]},{"title":"Java实现常见排序算法（一）","slug":"Java实现常见算法-一","date":"2019-05-05T12:35:38.000Z","updated":"2019-05-13T15:11:18.919Z","comments":true,"path":"2019/05/05/Java实现常见算法-一/","link":"","permalink":"http://yoursite.com/2019/05/05/Java实现常见算法-一/","excerpt":"","text":"在开发过程中使用得比较多的算法就是排序算法和查找算法了，今天先盘点一下常见的排序算法中的两个大类交换排序和插入排序。 交换排序快速排序基本思想：用选取的初始值（一般是第一个）将待排序序列分为小于初始值和大于初始值的两部分，然后重复此操作，最终到排序完成。该算法是一个不稳定的算法（如果待排序序列中存在相同的元素，经过排序后他们的相对位置不发生改变那么这个算法就是稳定的排序算法）空间复杂度最坏为O(n),平均为O(${log_2{n}}$)时间复杂度最坏为O(n2),最好为O(n${log_2{n}}$),平均O(n${log_2{n}}$)Java实现：12345678910111213141516171819202122232425262728public static int[] quickSort(int[] n, int low, int high) &#123; int lowMark = low, highMark = high; int record; if (low &lt; high) &#123; //记录值 record = n[low]; while (lowMark != highMark) &#123; //高位指针偏移 while (lowMark &lt; highMark &amp;&amp; n[highMark] &gt;= record) &#123; highMark--; &#125; //交换元素 n[lowMark] = n[highMark]; //低位指针偏移 while (lowMark &lt; highMark &amp;&amp; n[lowMark] &lt;= record) &#123; lowMark++; &#125; //交换元素 n[highMark] = n[lowMark]; &#125; //将记录值写到最后低位指针的位置 n[lowMark] = record; //两边分别进行排序操作 quickSort(n, low, lowMark - 1); quickSort(n, lowMark + 1, high); &#125; return n; &#125; 冒泡排序基本思想：设待排序的序列长度为n，从前往后（或者从后往前）两两比较相邻元素的值，根据自己需要升序或者降序交换两两元素的位置，直到整个序列比较完成，称为一趟冒泡排序，执行完n-1趟冒泡即可将所有元素排好。该算法是一个稳定的算法。空间复杂度为O(1)时间复杂度最坏为O(n2),最好为O(n),平均为O(n2)Java实现：1234567891011121314public static int[] bubbleSort(int[] nums) &#123; int temp; for (int i = 0; i &lt; nums.length; i++) &#123; for (int j = 0; j &lt; nums.length; j++) &#123; if (nums[i] &lt; nums[j]) &#123; //彼此交换,升序 temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; &#125; &#125; &#125; return nums; &#125; 插入排序直接插入排序基本思想：将元素分为有序区[0…i-1]和无序区[i…n-1],将R[i]插入到[0…i-1]中，并且使插入后的区域有序。当一个元素序列越接近有序，性能越好。该算法是一个稳定的算法。空间复杂度为O(1)时间复杂度最坏为O(n2)，最好为O(n)，平均为O(n2)Java实现：12345678910111213141516171819202122public static int[] insertSort(int[] n) &#123; int i, j, guard; for (i = 1; i &lt; n.length; i++) &#123; //如果i位置的数比他前面的数小，则进行遍历查找应该在有序数组中的插入位置 if (n[i] &lt; n[i - 1]) &#123; //更换哨兵 guard = n[i]; //从后向前查找 for (j = i - 1; j &gt;= 0; j--) &#123; //j位置如果大于哨兵，就交换当前查询数和比较数的位置 if (n[j] &gt; guard) &#123; n[j + 1] = n[j]; &#125; else &#123; break; &#125; &#125; //将哨兵位置放进去 n[j + 1] = guard; &#125; &#125; return n; &#125; 折半插入排序基本思想：排序思想和直接插入排序一致，区别在于折半插入排序在将元素插入到有序区时使用的是二分查找，可以减少关键字间的比较次数。该算法是一个稳定的算法。空间复杂度为O(1)时间复杂度平均为O(n2)Java实现：12345678910111213141516171819202122private static int[] halfInsertSort(int[] n) &#123; int i, j, low, high, mid, guard; for (i = 1; i &lt; n.length; i++) &#123; guard = n[i]; low = 0; high = i - 1; //与直接插入排序类似，只是查找插入位置时使用了二分查找 while (low &lt;= high) &#123; mid = (low + high) / 2; if (n[mid] &gt; guard) &#123; high = mid - 1; &#125; else &#123; low = mid + 1; &#125; &#125; for (j = i - 1; j &gt;= high + 1; j--) &#123; n[j + 1] = n[j]; &#125; n[high + 1] = guard; &#125; return n; &#125; 希尔排序基本思想：将待排序元素按下标进行增量分组，对每一组的元素采用直接插入排序，随着增量逐渐减小，所分成的组所含的元素越来越多，直到增量变成了1，所有的元素在一个分组中，即完成了排序。改算法是一个不稳定的算法。该算法可能不是很好理解，这里举一个例子。比如我们有[1,3,41,15,6,27,10,62,11,22]这样一个待排序的数组。首先我们确定一个增量5那么分组信息为[1,27],[3,10],[41,62],[15,11],[6,22]内部排序后变成了[1,3,41,11,6,27,10,62,15,22]第二次增量变成3分组信息为[1,11,10,22],[3,6,62],[41,27,15]内部排序后变成了[1,3,15,10,6,27,11,62,41,22]第三次增量变成1的即所有元素在一个分组中就成了[1,3,6,10,11,15,22,27,41,62]排序完成。PS.想要弄清关键词比较次数和记录移动次数与增量选择之间的关系，并给出完整的数学分析，今仍然是数学难题。希尔提出的办法是${d_1=n/2}$,${d_{i+1}=}\\lfloor{d_i}$/2$\\rfloor$,并且最后一个增量等于1空间复杂度：O(1)时间复杂度:O((n1.3-n2)Java实现：1234567891011121314151617181920private static int[] shellSort(int[] n) &#123; // i表示希尔排序中的第n/2+1个元素（或者n/4+1） // j表示希尔排序中从0到n/2的元素（n/4） // r表示希尔排序中n/2+1或者n/4+1的值 int i, j, r, tmp; // 划组排序 for (r = n.length / 2; r &gt;= 1; r = r / 2) &#123; for (i = r; i &lt; n.length; i++) &#123; tmp = n[i]; j = i - r; // 一轮排序 while (j &gt;= 0 &amp;&amp; tmp &lt; n[j]) &#123; n[j + r] = n[j]; j -= r; &#125; n[j + r] = tmp; &#125; &#125; return n; &#125;","categories":[{"name":"technology","slug":"technology","permalink":"http://yoursite.com/categories/technology/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}],"keywords":[{"name":"technology","slug":"technology","permalink":"http://yoursite.com/categories/technology/"}]}]}