{"meta":{"title":"AlexNine","subtitle":null,"description":null,"author":"AlexNine","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"Java实现常见排序算法（二）","slug":"Java实现常见算法-二","date":"2019-05-07T12:49:38.000Z","updated":"2019-05-13T15:11:25.524Z","comments":true,"path":"2019/05/07/Java实现常见算法-二/","link":"","permalink":"http://yoursite.com/2019/05/07/Java实现常见算法-二/","excerpt":"","text":"上次的博客讨论了排序算法中的插入排序和交换排序两个大类，今天将剩下的常见排序算法全部梳理出来 选择排序简单选择排序基本思想:每一趟排序从待排序的序列中选择出最小的元素，顺序放入到元素序列中，直到排序完成。该算法是一个不稳定的算法并且效率与初始数据顺序无关。空间复杂度为O(1)时间复杂度最高，平均，最低都为O(n2)Java实现：12345678910111213141516171819public static int[] selectInsert(int[] n) &#123; int minPos, temp; for (int i = 0; i &lt; n.length; i++) &#123; minPos = i; //遍历找出最小数的位置 for (int j = i + 1; j &lt; n.length; j++) &#123; if (n[j] &lt; n[minPos]) &#123; minPos = j; &#125; &#125; //如果最小数位置不等于当前位置指针，就交换位置，即把数按照从小到大的顺序依次排列 if (minPos != i) &#123; temp = n[i]; n[i] = n[minPos]; n[minPos] = temp; &#125; &#125; return n;&#125; 堆排序基本原理：堆排序是一种树形选择排序算法，其原理是将R[1…n]看成一棵完全二叉树的顺序存储结构。利用完全二叉树中双亲节点和孩子结点的关系，在当前无序区中选择关键字最大（最小）的元素构建成大根堆（小根堆）。堆排序的主要流程便是，建立大（小）根堆，然后输出元素（顶部和底部元素进行交换），再调整堆，直到元素全部输出。堆排序是一个不稳定的算法。堆的定义为：n个关键字序列R[1…n]称为堆，堆通常可以被看做一棵树的数组对象。当且仅当序列满足R[i]$\\leq$R[2i]且R[i]$\\leq$R[2i+1]时称为该堆为大根堆,其中1$\\leq$i$\\leq\\lfloor$n/2$\\rfloor$ 当且仅当序列满足R[i]$\\geq$R[2i]且R[i]$\\geq$R[2i+1]时称为该堆为小根堆,其中1$\\leq$i$\\leq\\lfloor$n/2$\\rfloor$比如在大根堆中，最大的元素放在根节点中，且对于任一非根节点，它的值小于等于其双亲节点的值。对于堆排序来说关键在于构造堆，而建堆是一个反复调整筛选的过程。首先从树的最后一个非叶子节点开始调整，按照堆的性质移动元素位置。如下图便是一个大顶推的调整过程。初始堆建立完成后，就是进行排序操作，排序操作的主要步骤是：以大根堆为例，每一次排序将堆顶元素与堆尾元素进行交换，然后再调用调整堆的算法使除了堆尾元素以外剩下的堆再次调整成一个大根堆，这样循环length-1次就可以将元素调整为从小到大的顺序，完成排序。空间复杂度为O(1)时间复杂度的最高，平均，最低都为O(nlog2n)Java实现：12345678910111213141516171819202122232425262728293031323334353637383940414243//堆排序private static int[] heapSort(int[] n) &#123; //建立堆，从最后一个非叶子节点开始 for (int i = (n.length - 2) / 2; i &gt;= 0; i--) &#123; adjustHeap(n, i, n.length); &#125; int temp; //完成排序，从最后一个元素进行输出，每次循环确定一个元素的位置 for (int i = n.length - 1; i &gt;= 1; i--) &#123; temp = n[0]; n[0] = n[i]; n[i] = temp; // 筛选 R[0] 结点，得到i个结点的堆 adjustHeap(n, 0, i); &#125; return n;&#125;//调整堆public static void adjustHeap(int[] n, int k, int length) &#123; //设置堆顶的值 int temp = n[k]; //从左孩子开始判断 for (int i = k * 2 + 1; i &lt;= length - 1; i = 2 * i + 1) &#123; //如果左孩子小于右孩子 if (i + 1 &lt; length &amp;&amp; n[i] &lt; n[i + 1]) &#123; //取右孩子 i++; &#125; //如果堆顶的值大于左右孩子中的较大者，无需调整 if (temp &gt;= n[i]) &#123; break; &#125; else &#123; //否则的话，将左右孩子中的较大者换到双亲节点 n[k] = n[i]; //然后将k值更新，方便继续向下调整 k = i; &#125; &#125; //将原堆顶位置当入最后调整出来的地方 n[k] = temp;&#125; 归并排序和基数排序归并排序基本思想：“归并”的意思是指将两个或者两个以上的有序表合并成一个新的有序表。假设一个待排序的序列长度为n，首先我们可以将其视为n个有序表，即每个表中元素个数为1，然后我们将n个有序表进行两两归并，得到$\\lceil$n/2$\\rceil$个长度为2或者1的有序表然后再再次基础上进行两两归并直到得到一个长度为n的有序表为止。这种方法就称为2路归并排序。归并排序是一个稳定的排序算法。PS.归并排序的发明者是约翰·冯·诺伊曼，其速度仅次于快速排序(平均状况下)例如我们有一个初始值为[22,11,32,2,12,83,10]的序列，才有2路归并排序第一趟归并后：[11,22],[2,32],[12,83],[10]第二趟归并后：[2,11,22,32],[10,12,83]第三趟归并后：[2,10,11,12,22,32,83]空间复杂度为O(n)时间复杂度的最高，平均，最低都为O(nlog2n)Java实现：1234567891011121314151617181920212223242526272829303132333435//归并排序public static int[] mergeSort(int[] n, int low, int high) &#123; int mid = (low + high) / 2; if (low &lt; high) &#123; mergeSort(n, low, mid); mergeSort(n, mid + 1, high); merge(n, low, mid, high); &#125; return n;&#125;//调整public static void merge(int[] n, int low, int mid, int high) &#123; int[] tempArr; int i = low, j = mid + 1, k = 0; tempArr = Arrays.copyOf(n, high - low + 1); // 把较小的数先移到新数组中 while (i &lt;= mid &amp;&amp; j &lt;= high) &#123; if (n[i] &lt; n[j]) &#123; tempArr[k++] = n[i++]; &#125; else &#123; tempArr[k++] = n[j++]; &#125; &#125; // 把左边剩余的数移入数组 while (i &lt;= mid) &#123; tempArr[k++] = n[i++]; &#125; // 把右边边剩余的数移入数组 while (j &lt;= high) &#123; tempArr[k++] = n[j++]; &#125; // 把新数组中的数覆盖nums数组 System.arraycopy(tempArr, 0, n, low, tempArr.length);&#125; 基数排序(桶子排序)基本思想：基数排序是一种不基于比较的排序，而采用多关键字排序思想，即基于关键字各位的大小进行排序，主要使用“分配”和“收集”两种基本操作对单逻辑关键字进行排序。基数排序又分为最高位优先(MSD)排序和最低位优先(LSD)排序。他的主要思想是将待排序的整数按位数切割成不同的数字，然后对每一位的数进行单独的比较，具体做法是：将所有待比较数值统一为同样的数位长度，如有不同位数则在前面进行补零操作，然后从最低位开始，依次进行一次排序，这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。举个栗子：待排序的数据为[222,123,580,996,965,854,775]，使用最低位优先排序第一趟将最低位进行排序：[580,222,123,854,965,775,996]第二趟将中间位进行排序：[222,123,854,965,775,580,996]第三趟将最高位进行排序：[123,222,580,775,854,965,996]空间复杂度：一趟排序需要的辅助空间为O(r)(r个队列或桶)用于存放d待排序的数时间复杂度：O(d(n+r)),d趟的分配和收集，一趟分配为O(n)，一趟收集为O(r)。Java实现(代码参考百度百科)12345678910111213141516171819202122232425262728//d表示最大的数有多少位public static int[] radixSort(int[] number, int d) &#123; //控制键值排序依据在哪一位 int k = 0,n = 1,m = 1; //数组的第一维表示可能的余数0-9 int[][] temp = new int[10][number.length]; //数组orderp[i]用来表示该位是i的数的个数 int[] order = new int[10]; while (m &lt;= d) &#123; for (int value : number) &#123; int lsd = ((value / n) % 10); temp[lsd][order[lsd]] = value; order[lsd]++; &#125; for (int i = 0; i &lt; 10; i++) &#123; if (order[i] != 0) for (int j = 0; j &lt; order[i]; j++) &#123; number[k] = temp[i][j]; k++; &#125; order[i] = 0; &#125; n *= 10; k = 0; m++; &#125; return number;&#125;","categories":[{"name":"technology","slug":"technology","permalink":"http://yoursite.com/categories/technology/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}],"keywords":[{"name":"technology","slug":"technology","permalink":"http://yoursite.com/categories/technology/"}]},{"title":"Java实现常见排序算法（一）","slug":"Java实现常见算法-一","date":"2019-05-05T12:35:38.000Z","updated":"2019-05-13T15:11:18.919Z","comments":true,"path":"2019/05/05/Java实现常见算法-一/","link":"","permalink":"http://yoursite.com/2019/05/05/Java实现常见算法-一/","excerpt":"","text":"在开发过程中使用得比较多的算法就是排序算法和查找算法了，今天先盘点一下常见的排序算法中的两个大类交换排序和插入排序。 交换排序快速排序基本思想：用选取的初始值（一般是第一个）将待排序序列分为小于初始值和大于初始值的两部分，然后重复此操作，最终到排序完成。该算法是一个不稳定的算法（如果待排序序列中存在相同的元素，经过排序后他们的相对位置不发生改变那么这个算法就是稳定的排序算法）空间复杂度最坏为O(n),平均为O(${log_2{n}}$)时间复杂度最坏为O(n2),最好为O(n${log_2{n}}$),平均O(n${log_2{n}}$)Java实现：12345678910111213141516171819202122232425262728public static int[] quickSort(int[] n, int low, int high) &#123; int lowMark = low, highMark = high; int record; if (low &lt; high) &#123; //记录值 record = n[low]; while (lowMark != highMark) &#123; //高位指针偏移 while (lowMark &lt; highMark &amp;&amp; n[highMark] &gt;= record) &#123; highMark--; &#125; //交换元素 n[lowMark] = n[highMark]; //低位指针偏移 while (lowMark &lt; highMark &amp;&amp; n[lowMark] &lt;= record) &#123; lowMark++; &#125; //交换元素 n[highMark] = n[lowMark]; &#125; //将记录值写到最后低位指针的位置 n[lowMark] = record; //两边分别进行排序操作 quickSort(n, low, lowMark - 1); quickSort(n, lowMark + 1, high); &#125; return n; &#125; 冒泡排序基本思想：设待排序的序列长度为n，从前往后（或者从后往前）两两比较相邻元素的值，根据自己需要升序或者降序交换两两元素的位置，直到整个序列比较完成，称为一趟冒泡排序，执行完n-1趟冒泡即可将所有元素排好。该算法是一个稳定的算法。空间复杂度为O(1)时间复杂度最坏为O(n2),最好为O(n),平均为O(n2)Java实现：1234567891011121314public static int[] bubbleSort(int[] nums) &#123; int temp; for (int i = 0; i &lt; nums.length; i++) &#123; for (int j = 0; j &lt; nums.length; j++) &#123; if (nums[i] &lt; nums[j]) &#123; //彼此交换,升序 temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; &#125; &#125; &#125; return nums; &#125; 插入排序直接插入排序基本思想：将元素分为有序区[0…i-1]和无序区[i…n-1],将R[i]插入到[0…i-1]中，并且使插入后的区域有序。当一个元素序列越接近有序，性能越好。该算法是一个稳定的算法。空间复杂度为O(1)时间复杂度最坏为O(n2)，最好为O(n)，平均为O(n2)Java实现：12345678910111213141516171819202122public static int[] insertSort(int[] n) &#123; int i, j, guard; for (i = 1; i &lt; n.length; i++) &#123; //如果i位置的数比他前面的数小，则进行遍历查找应该在有序数组中的插入位置 if (n[i] &lt; n[i - 1]) &#123; //更换哨兵 guard = n[i]; //从后向前查找 for (j = i - 1; j &gt;= 0; j--) &#123; //j位置如果大于哨兵，就交换当前查询数和比较数的位置 if (n[j] &gt; guard) &#123; n[j + 1] = n[j]; &#125; else &#123; break; &#125; &#125; //将哨兵位置放进去 n[j + 1] = guard; &#125; &#125; return n; &#125; 折半插入排序基本思想：排序思想和直接插入排序一致，区别在于折半插入排序在将元素插入到有序区时使用的是二分查找，可以减少关键字间的比较次数。该算法是一个稳定的算法。空间复杂度为O(1)时间复杂度平均为O(n2)Java实现：12345678910111213141516171819202122private static int[] halfInsertSort(int[] n) &#123; int i, j, low, high, mid, guard; for (i = 1; i &lt; n.length; i++) &#123; guard = n[i]; low = 0; high = i - 1; //与直接插入排序类似，只是查找插入位置时使用了二分查找 while (low &lt;= high) &#123; mid = (low + high) / 2; if (n[mid] &gt; guard) &#123; high = mid - 1; &#125; else &#123; low = mid + 1; &#125; &#125; for (j = i - 1; j &gt;= high + 1; j--) &#123; n[j + 1] = n[j]; &#125; n[high + 1] = guard; &#125; return n; &#125; 希尔排序基本思想：将待排序元素按下标进行增量分组，对每一组的元素采用直接插入排序，随着增量逐渐减小，所分成的组所含的元素越来越多，直到增量变成了1，所有的元素在一个分组中，即完成了排序。改算法是一个不稳定的算法。该算法可能不是很好理解，这里举一个例子。比如我们有[1,3,41,15,6,27,10,62,11,22]这样一个待排序的数组。首先我们确定一个增量5那么分组信息为[1,27],[3,10],[41,62],[15,11],[6,22]内部排序后变成了[1,3,41,11,6,27,10,62,15,22]第二次增量变成3分组信息为[1,11,10,22],[3,6,62],[41,27,15]内部排序后变成了[1,3,15,10,6,27,11,62,41,22]第三次增量变成1的即所有元素在一个分组中就成了[1,3,6,10,11,15,22,27,41,62]排序完成。PS.想要弄清关键词比较次数和记录移动次数与增量选择之间的关系，并给出完整的数学分析，今仍然是数学难题。希尔提出的办法是${d_1=n/2}$,${d_{i+1}=}\\lfloor{d_i}$/2$\\rfloor$,并且最后一个增量等于1空间复杂度：O(1)时间复杂度:O((n1.3-n2)Java实现：1234567891011121314151617181920private static int[] shellSort(int[] n) &#123; // i表示希尔排序中的第n/2+1个元素（或者n/4+1） // j表示希尔排序中从0到n/2的元素（n/4） // r表示希尔排序中n/2+1或者n/4+1的值 int i, j, r, tmp; // 划组排序 for (r = n.length / 2; r &gt;= 1; r = r / 2) &#123; for (i = r; i &lt; n.length; i++) &#123; tmp = n[i]; j = i - r; // 一轮排序 while (j &gt;= 0 &amp;&amp; tmp &lt; n[j]) &#123; n[j + r] = n[j]; j -= r; &#125; n[j + r] = tmp; &#125; &#125; return n; &#125;","categories":[{"name":"technology","slug":"technology","permalink":"http://yoursite.com/categories/technology/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}],"keywords":[{"name":"technology","slug":"technology","permalink":"http://yoursite.com/categories/technology/"}]}]}